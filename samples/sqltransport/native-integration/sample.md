---
title: Native integration
summary: Integrating natively with the SQL Server transport.
reviewed: 2016-03-30
component: SqlServer
related:
- transports/msmq
- transports/sqlserver
- persistence/nhibernate
---


## Introduction

This sample demonstrates how to send messages to an `NServiceBus` endpoint running on the `SqlServerTransport` directly from the database using T-SQL statements. It also shows how to do that using ADO.NET.


## Running the sample

 1. Ensure a SQL Server Express is running and accessible as `.\SQLEXPRESS`.
 1. Create a database `samples`
 1. Start the Receiver project.
 1. In the Receiver's console notice `Press enter to send a message. Press any key to exit` text when the app is ready.
 1. Hit enter key.
 1. A message will be sent using ADO.NET and be received by the app.
 1. Open SQL Server Management Studio and go to the `samples` database.
 1. Open the Scripts.sql included in the sample.
 1. Run the `SendFromTSQL` statement.
 1. Notice how the app shows that a new message has been processed.
 1. Create the `Orders` table using the `CreateLegacyTable` statement.
 1. Create the insert trigger using the `CreateTrigger` statement.
 1. Right click the table just created and do `Edit top X rows`.
 1. Notice that a message is received by the app for each "order" created.


## Code walk-through

The first thing when doing native integration with the SQL Server transport is figure out where to insert the "message". The database and server names can easily be found by looking at the connection string and the table name is, by default, the same as the endpoint's name. The endpoint configuration is as follows:

snippet: EndpointConfiguration

The table would be `Samples.SqlServer.NativeIntegration` in the database `samples` on server `.\SQLEXPRESS` (localhost).


### Serialization

In this sample JSON will be used to serialize the messages but XML would have worked equally well. To configure the endpoint call `.UseSerialization<JsonSerializer>()` as shown above.

Now the endpoint can understand JSON payloads a message contract can be defined. In NServiceBus messages are C# classes.

snippet: MessageContract

The final step is to tell the serializer what C# class the JSON payload belongs to. This is done using the Json.NET `$type` attribute. The message body will then look as follows:

snippet: MessagePayload

With this in place the endpoint can now parse the incoming JSON payload to a strongly typed message and invoke the correct message handlers.


### Sending the message

Sending a message to the endpoint using ADO.NET is done via:

snippet: SendingUsingAdoNet

Armed with this it will be possible to send messages from any app in the organization that supports ADO.NET.


## Sending from within the database

Sometimes it is necessary to integrate with old legacy apps where performing sends straight from within the database itself might be a better approach. Just execute the following SQL statement and notice how the message is consumed by the NServiceBus endpoint.

snippet: SendFromTSQL


### Using triggers to emit messages

Sometimes legacy systems are not allowed to be modified. It is in this scenario where triggers are useful.

Create a fictive `Orders` table using

snippet: CreateLegacyTable

And create an `on inserted` trigger that will send a `LegacyOrderDetected` message for each new order that is added to the table. Here's the trigger:

snippet: CreateTrigger

Notice how a unique message ID is generated by hashing the identity column. NServiceBus requires each message to have a unique ID in order to safely perform retries.

Add a few orders to the table and notice how the app receives the messages. In a real life scenario the trigger would likely do a `Publish` to push an `OrderAccepted` event out on the queue.

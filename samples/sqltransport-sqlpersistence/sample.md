---
title: SQL Server Transport and SQL Persistence
summary: Integrating the SQL Server transport with SQL persistence
reviewed: 2019-03-29
component: Core
related:
- persistence/sql
- transports/sql
---

In this sample, the [SQL Server transport](/transports/sql/) is used in conjunction with the [SQL persister](/persistence/sql/). The sample shows how to use the same database connection for both transport and persistence operations, and how to access (using multiple [ORMs](https://en.wikipedia.org/wiki/Object-relational_mapping)) the current SQL connection and transaction from within a message handler to persist business objects to the database.

include: persistence-session-note


## Prerequisites

include: sql-prereq

The database created by this sample is `NsbSamplesSql`.


## Procedure

 1. Start the Sender and Receiver projects.
 1. In the Sender's console, press <kbd>enter</kbd>> to send a message when the app is ready.
 1. On the Receiver console notice that order was submitted.
 1. On the Sender console notice that the order was accepted.
 1. Finally, after a couple of seconds, on the Receiver console notice that the timeout message has been received.
 1. Open SQL Server Management Studio and go to the `NsbSamplesSql` database. Verify that there is a row in the saga state table (`receiver.OrderLifecycleSaga`) and in the orders table (`receiver.SubmittedOrder`)


## Code walk-through

This sample contains three projects:

 * Shared - A class library containing common code including the message definitions.
 * Sender - A console application responsible for sending the initial `OrderSubmitted` message and processing the follow-up `OrderAccepted` message.
 * Receiver - A console application responsible for processing the order message.

Sender and Receiver use different schemas within one database. This creates a logical separation (since schemas can be secured independently) while retaining the benefits of having a single physical database. Apart from business data, each schema contains queues for the NServiceBus endpoint and tables for the NServiceBus persister. If no schema is specified, the transport will default to the `dbo` schema.


## Sender project

The Sender mimics the front-end system where orders are submitted by customers and passed as messages to the back-end. It is configured to use the [SQL Server transport](/transports/sql/) and the [in-memory persister](/persistence/in-memory.md). In-meemory persistence is used since for the purposes of this sample, Sender does not need to persist data. The transport is configured to use `sender` for the schema.

snippet: SenderConfiguration


## Receiver project

The Receiver mimics a back-end system. It is also configured to use the [SQL Server transport](/transports/sql/) and the [SQL persister](/persistence/sql/). The transport is configured to use `receiver` for the schema and to send messages addressed to the `receiver` endpoint to a different schema.

snippet: ReceiverConfiguration

When the message arrives at the Receiver, a `TransactionScope` is created that:

 * Dequeues the message.
 * Opens a [DBConnection](https://msdn.microsoft.com/en-us/library/system.data.common.dbconnection.aspx) and starts a [DBTransaction](https://msdn.microsoft.com/en-us/library/system.data.common.dbtransaction.aspx), supplying both to all handlers and sagas.
 * Persists saga data for `OrderLifecycleSaga`.
 * Sends a reply message and s timeout request.


### Script output

The Receiver contains an attribute in the **SqlPersistenceSettings.cs** file which instructs the SQL persister to generate table creation scripts for only Microsoft SQL Server.

snippet: SqlPersistenceSettings

The SQL scripts, generated by the SQL persister at build time, will be created in the following directory:

```
Receiver\bin\Debug\net462\NServiceBus.Persistence.Sql
```


### Accessing the ambient database details

When persisting data to the same database, it is recommended to use the same [DBConnection](https://msdn.microsoft.com/en-us/library/system.data.common.dbconnection.aspx) and [DBTransaction](https://msdn.microsoft.com/en-us/library/system.data.common.dbtransaction.aspx) that is used by the underlying persister and transport. The approach to this differs depending on the approach used to persist the data. Several approaches to data access, including raw ADO.NET and several ORMs, are listed below.

NOTE: The connection and transaction are managed by NServiceBus, so there is no need to explicitly commit a transaction or dispose the connection. Using the database state managed by NServiceBus ensures that database interactions, both in handlers and sagas, execute in the same connection and transaction context.


#### Raw [ADO.NET](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ado-net-overview)


##### Persisting Data

snippet: StoreDataRaw


#### [Dapper](https://github.com/StackExchange/Dapper)


##### Model

snippet: SubmittedOrderDapper


##### Persisting Data

snippet: StoreDataDapper


#### [EntityFramework](https://docs.microsoft.com/en-us/ef/core/)


##### Model

The schema is defined using an attribute. The table name is redefined as the class name as it is a required parameter.

snippet: SubmittedOrderEF


##### DBContext

Entity Framework requires an implementation of [DBContext](https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext) to persist data.

snippet: SubmittedOrderDbContext


##### Persisting data

snippet: StoreDataEf


#### [ServiceStack OrmLite](https://github.com/ServiceStack/ServiceStack.OrmLite)


##### Model

The schema is defined using an attribute.

snippet: SubmittedOrderOrmLite


##### Persisting data

snippet: StoreDataOrmLite


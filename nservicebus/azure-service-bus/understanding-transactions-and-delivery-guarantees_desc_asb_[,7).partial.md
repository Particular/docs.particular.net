NServiceBus relies on transaction scopes to control how it behaves when it comes to transactions, message dispatching and commit/rollback guarantees. The architecture is schematically represented like this:

![Transactions v6](transactions-v6.png)

The Azure Service Bus library, which is used in the Azure Service Bus transport, has a few requirements, when it is used inside a transaction scope, that must be taken into account.
* It requires the use of the `Serializable` isolation level when it's used inside a transaction scope. For more information refer to [Transaction Isolation Levels Explained in Details](http://dotnetspeak.com/2013/04/transaction-isolation-levels-explained-in-details/) article. Therefore Azure Service Bus transport will always use `Serializable` isolation level to comply with the Azure Service Bus SDK requirements.
* It also proactively checks to see whether it is used alone inside a transaction and it will throw an exception if used together with another transactional resource such as a database connection. To allow the user code to still use a transaction for it's database connections, in another transaction scope provided by NServiceBus around a handler, the 2 scopes are kept apart and synchronized using an implementation of `IEnlistmentNotification` for both the send and completion operations. (Schematically represented by the orange to yellow star notation in the diagram)
* Finally, it does not allow send operation on different messaging entities in the same transaction. So for example a send to Queue1 and a send to Queue2 in the same scope, will throw an exception. Again this problem is negated using separate instances of `IEnlistmentNotification` on each send operation. 

The benefit of this approach is that user code can use database connections and send messages to multiple endpoints while maintaining the aspects expected from a transaction. However the downside is that each transport operation (such as message sending) is individual. Even though they are executed at the same moment in a transaction, it can happen in theory that one of the operations fails, while the others do not. This problem is again mitigated by using multiple layers of retry behavior to reduce the chance, so a short interruption in connectivity or broker outage will not have a significant impact and operations will eventually succeed. However a full outage right after the database transaction committed could lead to a send operation that did not execute. This implies that business data could have been written, but outbound messages would not be sent out.

NOTE: The maximum guarantee that the transport can deliver in these versions is in effect `ReceiveOnly`. 

NOTE: Enabling/Disabling DTC will have no effect, this setting is ignored either way as Azure Service Bus does not support it.

WARNING: Disabling transactions will also turn off the `PeekLock` mechanism, so that the transport immediately completes any incoming message before processing and shows no retry behavior. 
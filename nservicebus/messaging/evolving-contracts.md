---
title: Evolving Message Contracts
summary: Guidelines for choosing a strategy for evolving message contracts
reviewed: 2020-06-16
component: Core
isLearningPath: true
---

In message-based systems, the messages are part of the contract, which defines how services communicate with each other.

Evolving contracts over time is not an easy task and the appropriate strategy should be defined individually for each system. Generally the problem can't be resolved at the infrastructure level; therefore NServiceBus users must analyze their individual systems, consider how they are expected to evolve, and define the strategy which will make the most sense in their particular circumstances.

This article presents basic guidelines for choosing contracts evolution strategy, avoiding common mistakes, and ensuring that contracts will be easy to evolve over time.


## Designing contracts


### Messages

Ensure that messages can be evolved by following general [messages design guidelines](/nservicebus/messaging/messages-events-commands.md#designing-messages).


## Common challenges


### Default values

When a message is extended with additional properties, it's necessary to carefully examine what will be the default values for those properties, especially if endpoints running in other versions don't recognize them. In particular, it's important to consider how clients might interpret the default value and provide appropriate guidelines for them.

In some cases, a default value might be insufficient, and in order to accurately process the message, the value must be up to date. If the actual value of the added property is stored in a storage already accessible to the handler, the handler may retrieve that data as part of the message processing. However, in most cases, the actual value is stored by another service and it's not desirable to access the data directly from the handler.

In such a case, the following steps can help:

* Convert the original message handler to be part of a (new) saga
* When the message is received, and the handler identifies that a part of the data is missing, send a dedicated message to the relevant endpoint to retrieve the missing information. 
* When the data is retrieved, another dedicated message handler can handle the complete message


### Handling breaking changes in contracts

There are a number of approaches to handling breaking changes in messages. One of the simplest is adding a version to the type name and creating handlers for the new contract. The handlers for the old contract might still be running, to handle in-flight messages and messages generated by old endpoints.

When there are significant changes in a message type, such as adding or removing properties, or changing the property type, the upgrade process should consist of the following steps:

 * Update the contract to the new version.
 * Update senders to use the new contract version. Ensure changes are visible for receivers, for example, by decorating the existing property with the `Obsolete` attribute when removing or renaming properties.
 * Update receivers to handle the new contract version. Make sure the new properties are handled correctly, e.g. instead of relying on .NET to set the default value for `int Age = 1`, it's better to use nullable types and represent missing values as `null`.
 * When all senders and receivers are updated and in-flight messages in the old format have been handled, obsolete the properties and throw an error, or simply remove them.

Another approach for handling breaking changes is to modify serialization formats. The step-by-step guidance is provided in the [transition serialization formats](/samples/serializers/transitioning-formats/) formats.

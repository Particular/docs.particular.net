---
title: Evolving Message Contracts
summary: Guidelines for choosing a strategy for evolving message contracts
reviewed: 2020-06-16
component: Core
isLearningPath: true
---

In message-based systems, the messages are part of the contract, which defines how services communicate with each other.

Evolving contracts over time is not an easy task and the appropriate strategy should be defined individually for each system. Generally the problem can't be resolved at the infrastructure level; therefore NServiceBus users must analyze their individual systems, consider how they are expected to evolve, and define the strategy which will make the most sense in their particular circumstances.

This article presents basic guidelines for choosing contracts evolution strategy, avoiding common mistakes, and ensuring that contracts will be easy to evolve over time.


## Designing contracts


### Messages

Ensure that messages can be evolved by following general [messages design guidelines](/nservicebus/messaging/messages-events-commands.md#designing-messages).


## Common challenges

### Handling breaking changes in contracts

There are a number of approaches to handling breaking changes in messages. One of the simplest is adding a version to the type name and creating handlers for the new contract. The handlers for the old contract might still be running, to handle in-flight messages and messages generated by old endpoints.

For complex systems, especially when there are significant changes in a message type, such as adding or removing properties, or changing the property type, we recommend a step-by-step approach to evolving message contracts.

#### Adding data to a contract

Depending on the complexity of the system, multiple options are possible. The simplest one is to:

* Update the contract to the new version.
* Update senders to use the new contract version. Ensure changes are visible for receivers, for example, by decorating the existing property with the Obsolete attribute when removing or renaming properties.
* Update receivers to handle the new contract version. It's important that the new properties are handled correctly:
  * It's necessary to carefully examine what the default values for the added properties will be, especially if endpoints running in other versions don't recognize them. In particular, it's important to consider how clients might interpret the default value and provide appropriate guidelines for them.
  * Instead of relying on .NET to set the default value for int Age = 1, it's better to use nullable types and represent missing values as null.

For more complex systems, especially when receivers need to be gradually upgraded, a more gradual upgrade is recommended.

For the contracts assembly:

* Create a new contract that inherits the previous version instead of adjusting the same type
* Release a new version of the contract's assembly

For senders and publishers:

* Update senders and publishers to target the new contracts assembly
* Update senders and publishers use the new message contract

This may be done gradually, deploying endpoint by endpoint as suited.

For receivers and subscribers:

* Update receivers to target the new contracts assembly
* Add an additonal handler that can handle new message contract
* Adjust the handler that handled the previous contract version by:
  * Adjust message processing by assigning a default value to the missing properties.  It's necessary to carefully examine what the default values for the added properties will be, especially if endpoints running in other versions don't recognize them. In particular, it's important to consider how clients might interpret the default value and provide appropriate guidelines for them.
  * When the actual values for the new properties are required and the data is available in the storage, it can be retrieved as part of the message processing
  * When the new properties are required to correctly process the message and are stored by another service:
    * Convert the original message handler to initiate a saga
    * When the message is received, and the handler identifies that a part of the data is missing, send a dedicated message to the relevant endpoint to retrieve the missing information. If needed, keep track of the data from the original message by storing all relevant information in the saga
    * When the data is retrieved, a new message containing all required information can be sent. This message will be handled by the same handler that processes the new message contract type, deferring the actual processing to a single handler.

When all senders and receivers are updated and in-flight messages in the old format have been handled, the previous contract type can be obsoleted. By decorating the previous contract type with the `Obsolete` attribute, the changes become visible for receivers when they upgrade to the new version.
In a next major version, the obsoloted types may be removed.

#### Removing data from a contract



#### Modifying serialization formats

Another approach for handling breaking changes is to modify serialization formats. The step-by-step guidance is provided in the [transition serialization formats](/samples/serializers/transitioning-formats/) formats.

### Breaking down large contract assemblies

In the early days of a system, combining all events, commands and messages into a single contracts assembly might make a lot of sense. However, as the system grows, breaking down the contracts into smaller parts makes more sense. An obvious reason is a rise in the number of subscribers for events published by a specific endpoint. It's not desirable to expose commands that are meant to be consumed by a single receiver to all the subscribers interested in that same endpoint's events.

At that point it makes more sense to break down the contracts into multiple assemblies. A possible structure solution is to have multiple assemblies per endpoint with a naming convention similar to:

* ServiceName.Commands
* ServiceName.Events

Or even more strict:

* ServiceName.AutonomousComponent.Commands
* ServiceName.AutonomousComponent.Events

While it might make sense to directly reference the \*.Commands assemblies from the sender and receiver endpoints, it might not for the \*.Events assemblies as they are used by many subscribing endpoints. In those cases, it could make sense to share the assembly through NuGet packages as opposed to using a direct reference.

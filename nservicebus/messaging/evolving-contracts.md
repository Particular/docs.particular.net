---
title: Evolving Message Contracts
summary: Guidelines for choosing a strategy for evolving message contracts
reviewed: 2020-06-16
component: Core
isLearningPath: true
---

In message-based systems, the messages are part of the contract, which defines how services communicate with each other.

Evolving contracts over time is not an easy task and the appropriate strategy should be defined individually for each system. Generally the problem can't be resolved at the infrastructure level; therefore NServiceBus users must analyze their individual systems, consider how they are expected to evolve, and define the strategy which will make the most sense in their particular circumstances.

This article presents basic guidelines for choosing contracts evolution strategy, avoiding common mistakes, and ensuring that contracts will be easy to evolve over time.


## Designing contracts


### Messages

Ensure that messages can be evolved by following general [messages design guidelines](/nservicebus/messaging/messages-events-commands.md#designing-messages).


## Common challenges

### Handling breaking changes in contracts

There are a number of approaches to handling breaking changes in messages. One of the simplest is adding a version to the type name and creating handlers for the new contract. The handlers for the old contract might still be running, to handle in-flight messages and messages generated by old endpoints.

For complex systems, especially when there are significant changes in a message type, such as adding or removing properties, or changing the property type, we recommend a step-by-step approach to evolving message contracts.

#### Adding data to a contract

Depending on the complexity of the system, multiple options are possible. The simplest one is to:

* Update the contract to the new version.
* Update senders to use the new contract version. Ensure changes are visible for receivers, for example, by decorating the existing property with the Obsolete attribute when removing or renaming properties.
* Update receivers to handle the new contract version. It's important that the new properties are handled correctly:
  * It's necessary to carefully examine what the default values for the added properties will be, especially if endpoints running in other versions don't recognize them. In particular, it's important to consider how clients might interpret the default value and provide appropriate guidelines for them.
  * Instead of relying on .NET to set the default value for int Age = 1, it's better to use nullable types and represent missing values as null.

For more complex systems, especially when receivers need to be gradually upgraded, a more gradual upgrade is recommended:

* Create a new contract that inherits the previous version instead of adjusting the same type
* Release vX.1 of the contract's assembly
* Update senders to use the new contract version, this may be done gradually, deploying endpoint by endpoint as suited.
* Update receivers to handle the new contract version by adding an additonal handler that can handle the new contract type
* Update receivers that handle the old contract version by:
  * Processing the message assigning a default value to the missing properties.  It's necessary to carefully examine what the default values for the added properties will be, especially if endpoints running in other versions don't recognize them. In particular, it's important to consider how clients might interpret the default value and provide appropriate guidelines for them.
  * When the actual values for the new properties are required and the data is available in the storage, it can be retrieved as part of the message processing
  * When the new properties are required to correctly process the message and are stored by another service:
    * Convert the original message handler to initiate a saga
    * When the message is received, and the handler identifies that a part of the data is missing, send a dedicated message to the relevant endpoint to retrieve the missing information. If needed, keep track of the data from the original message by storing all relevant information in the saga
    * When the data is retrieved, a new message containing all required information can be sent. This message will be handled by the same handler that processes the new message contract type, deferring the actual processing to a single handler.

When all senders and receivers are updated and in-flight messages in the old format have been handled, the previous contract type can be obsoleted. By decorating the previous contract type with the `Obsolete` attribute, the changes become visible for receivers when they upgrade to the new version.
In a next major version, the obsoloted types may be removed.

#### Removing data from a contract



#### Modifying serialization formats

Another approach for handling breaking changes is to modify serialization formats. The step-by-step guidance is provided in the [transition serialization formats](/samples/serializers/transitioning-formats/) formats.
